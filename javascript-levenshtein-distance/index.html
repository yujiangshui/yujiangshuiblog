<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1">
    <meta name="renderer" content="webkit">
    
    <title>使用 JavaScript 实现简单候选项推荐功能（模糊搜索） | 于江水</title>
    <meta name="description" content="当我们使用 Google 等搜索功能时，会出现与搜索内容有关的候选项。使用 JavaScript 搜索字符串，通常会使用 indexOf 或者 search 函数，但是非常僵硬，只能搜索匹配特定词语。比如使用关键词 今天是星期几 想要检索 今天是星期五 这个内容，就无法实现，虽然它们只有很小的差别。 本文就来介绍一个有趣的算法 编辑距离（Levenshtein Distance），然后用它来实现一">
<meta property="og:type" content="article">
<meta property="og:title" content="使用 JavaScript 实现简单候选项推荐功能（模糊搜索）">
<meta property="og:url" content="http://yujiangshui.com/javascript-levenshtein-distance/index.html">
<meta property="og:site_name" content="于江水">
<meta property="og:description" content="当我们使用 Google 等搜索功能时，会出现与搜索内容有关的候选项。使用 JavaScript 搜索字符串，通常会使用 indexOf 或者 search 函数，但是非常僵硬，只能搜索匹配特定词语。比如使用关键词 今天是星期几 想要检索 今天是星期五 这个内容，就无法实现，虽然它们只有很小的差别。 本文就来介绍一个有趣的算法 编辑距离（Levenshtein Distance），然后用它来实现一">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://jiangshui.b0.upaiyun.com/blog/2015/01/ed0.webp">
<meta property="og:image" content="http://jiangshui.b0.upaiyun.com/blog/2015/01/ed1.webp">
<meta property="og:image" content="http://jiangshui.b0.upaiyun.com/blog/2015/01/ed3.webp">
<meta property="og:updated_time" content="2019-04-10T00:17:52.180Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="使用 JavaScript 实现简单候选项推荐功能（模糊搜索）">
<meta name="twitter:description" content="当我们使用 Google 等搜索功能时，会出现与搜索内容有关的候选项。使用 JavaScript 搜索字符串，通常会使用 indexOf 或者 search 函数，但是非常僵硬，只能搜索匹配特定词语。比如使用关键词 今天是星期几 想要检索 今天是星期五 这个内容，就无法实现，虽然它们只有很小的差别。 本文就来介绍一个有趣的算法 编辑距离（Levenshtein Distance），然后用它来实现一">
<meta name="twitter:image" content="http://jiangshui.b0.upaiyun.com/blog/2015/01/ed0.webp">
<meta name="twitter:creator" content="@yujiangshui">
<meta property="fb:admins" content="yujiangshui"> 
    <link rel="alternate" href="/atom.xml" title="于江水" type="application/rss+xml">
    

    <link rel="stylesheet" href="//static.zhjan.com/blog/yujiangshui/assets/jiangshui-simple/0.0.1/css/style.css">
    <script data-main="//static.zhjan.com/blog/yujiangshui/assets/jiangshui-simple/0.0.1/js/build" src="//static.zhjan.com/blog/yujiangshui/assets/jiangshui-simple/0.0.1/js/require.js"></script>
    <!--[if lt IE 7]>
      <style>
        .section {
          width: 780px;
        }
        .post-content img {
          width: 100%;
        }
        .jupe pre {
          width: 100%;
        }
      </style>
    <![endif]-->
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-57557739-5"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());

      gtag('config', 'UA-57557739-5');
    </script>
  </head>
</html>

<body>

<div class="section-wrap section-main">
	<div class="section">
		<div class="header">
	<h1 class="logo">
		<a href="/">于江水</a>
	</h1>
	<p class="social-links">
		<a href="http://www.weibo.com/yujiangshui">Weibo</a>
		\
		<a href="https://twitter.com/yujiangshui">Twitter</a>
		\
		<a href="https://github.com/yujiangshui">Github</a>
		\
		<a href="/atom.xml">RSS</a>
	</p>
</div>
		<div class="main">
			<div class="jupe main-body">
  <div class="post-content">
    <h1 class="post-title">使用 JavaScript 实现简单候选项推荐功能（模糊搜索）</h1>
    <div class="post-meta">
      <span class="post-time">2015.01.21</span>
      <div class="post-cats">
        <a class="post-cats-item-link" href="/category/JavaScript/">JavaScript</a>
      </div>
    </div>
    <div class="post-toc">
      <div class="toc-title">TOC</div>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#编辑距离（Levenshtein-Distance）"><span class="toc-number">1.</span> <span class="toc-text">编辑距离（Levenshtein Distance）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实际应用"><span class="toc-number">2.</span> <span class="toc-text">实际应用</span></a></li></ol>
    </div>
    <p>当我们使用 Google 等搜索功能时，会出现与搜索内容有关的候选项。使用 JavaScript 搜索字符串，通常会使用 <code>indexOf</code> 或者 <code>search</code> 函数，但是非常僵硬，只能搜索匹配特定词语。比如使用关键词 <code>今天是星期几</code> 想要检索 <code>今天是星期五</code> 这个内容，就无法实现，虽然它们只有很小的差别。</p>
<p>本文就来介绍一个有趣的算法 <a href="http://baike.baidu.com/view/2020247.htm" target="_blank" rel="noopener">编辑距离（Levenshtein Distance）</a>，然后用它来实现一个简单的候选项推荐（模糊搜索）功能。</p>
<h2 id="编辑距离（Levenshtein-Distance）"><a href="#编辑距离（Levenshtein-Distance）" class="headerlink" title="编辑距离（Levenshtein Distance）"></a>编辑距离（Levenshtein Distance）</h2><p>简单的说，编辑距离就是把一个字符串修改变成另一个字符串的修改次数。如果修改的次数越小，我们可以简单的认为这两个字符串之间的关系越紧密。比如 <code>今天是星期几</code> 对于 <code>今天是星期五</code> 和 <code>明天是星期五</code>比较，跟 <code>今天是星期五</code> 更加紧密一些，因为前者的编辑距离是 1，后者的编辑距离是 2。</p>
<p>更详细的百度百科已经说的很清楚了，这里不再赘述，主要给出 JavaScript 的实现方法：</p>
<p>按照自然语言表达的算法，我们先需要根据两个字符串的长度创建一个二维表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function levenshtein(a, b) &#123;</span><br><span class="line"></span><br><span class="line">	var al = a.length + 1;</span><br><span class="line">	var bl = b.length + 1;</span><br><span class="line">	var result = [];</span><br><span class="line">	var temp = 0;</span><br><span class="line"></span><br><span class="line">	// 创建一个二维数组</span><br><span class="line">	for (var i = 0; i &lt; al; result[i] = [i++]) &#123;&#125;</span><br><span class="line">	for (var i = 0; i &lt; bl; result[0][i] = i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后就需要遍历这个二位数组，按照如下的规则取得三个值的最小值：</p>
<ul>
<li>如果最上方的字符等于最左方的字符，则为左上方的数字。否则为左上方的数字 + 1。</li>
<li>左方数字 + 1</li>
<li>上方数字 + 1</li>
</ul>
<p>需要判断两个值是否相等来决定左上方数字是否 + 1，所以引入 temp 变量。我们可以写出如下遍历代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (i = 1; i &lt; al; i++) &#123;</span><br><span class="line">	for (var j = 1; j &lt; bl; j++) &#123;</span><br><span class="line">		// 判断最上方和最左方数字是否相等</span><br><span class="line">		temp = a[i - 1] == b[j - 1] ? 0 : 1;</span><br><span class="line">		// result[i - 1][j] + 1 左方数字</span><br><span class="line">		// result[i][j - 1] + 1 上方数字</span><br><span class="line">		// result[i - 1][j - 1] + temp 左上方数字</span><br><span class="line">		result[i][j] = Math.min(result[i - 1][j] + 1, result[i][j - 1] + 1, result[i - 1][j - 1] + temp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后将二维数组最后一个值返回，该值就是编辑距离：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return result[i-1][j-1];</span><br></pre></td></tr></table></figure>
<p>这个函数就完成了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function levenshtein(a, b) &#123;</span><br><span class="line"></span><br><span class="line">	var al = a.length + 1;</span><br><span class="line">	var bl = b.length + 1;</span><br><span class="line">	var result = [];</span><br><span class="line">	var temp = 0;</span><br><span class="line"></span><br><span class="line">	// 创建一个二维数组</span><br><span class="line">	for (var i = 0; i &lt; al; result[i] = [i++]) &#123;&#125;</span><br><span class="line">	for (var i = 0; i &lt; bl; result[0][i] = i++) &#123;&#125;		</span><br><span class="line"></span><br><span class="line">	for (i = 1; i &lt; al; i++) &#123;</span><br><span class="line">		for (var j = 1; j &lt; bl; j++) &#123;</span><br><span class="line">			// 判断最上方和最左方数字是否相等</span><br><span class="line">			temp = a[i - 1] == b[j - 1] ? 0 : 1;</span><br><span class="line">			// result[i - 1][j] + 1 左方数字</span><br><span class="line">			// result[i][j - 1] + 1 上方数字</span><br><span class="line">			// result[i - 1][j - 1] + temp 左上方数字</span><br><span class="line">			result[i][j] = Math.min(result[i - 1][j] + 1, result[i][j - 1] + 1, result[i - 1][j - 1] + temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return result[i-1][j-1];</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>那么我们现在就来实现一个简单的搜索功能。</p>
<p>大体思路就是将数据与要搜索的字符串计算编辑距离，然后进行排序，将编辑距离小的放在上面显示。具体 Demo 做在 jsfiddle 上面了：</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/yujiangshui/ds6ztf8d/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<p>也可以<a href="http://jsfiddle.net/yujiangshui/ds6ztf8d/" target="_blank" rel="noopener">点击这里</a>查看。</p>
<p>使用起来是有点效果的，比如：</p>
<p><img src="http://jiangshui.b0.upaiyun.com/blog/2015/01/ed0.webp" alt></p>
<p>和</p>
<p><img src="http://jiangshui.b0.upaiyun.com/blog/2015/01/ed1.webp" alt></p>
<p>但是也有很大的偏差，比如要搜索的关键词和相似结果编辑距离太大，超过了同等长度的不同字符，这时候就会出现错误的推荐：</p>
<p><img src="http://jiangshui.b0.upaiyun.com/blog/2015/01/ed3.webp" alt></p>
<p>如果数据足够多，各种情况都具备，那么推荐准确的可能性更大些。如果要改善这个功能，可能需要结合中文分词对关键词进行匹配综合等等，超出本文范畴这里不再赘述。</p>
<p>如果你有更好的方法和思路，欢迎留言讨论。</p>

  </div>
  <div class="post-share">
	<ul class="share-list">
		<li><a class="icon icon-weibo" href="javascript:share.weibo();"><span>weibo</span></a></li>
		<li><a class="icon icon-twitter" href="javascript:share.twitter();"><span>twitter</span></a></li>
		<li><a class="icon icon-douban" href="javascript:share.douban();"><span>douban</span></a></li>
		<li><a class="icon icon-qzone" href="javascript:share.qzone();"><span>qzone</span></a></li>
	</ul>
</div>
</div>
		</div>
		<div class="footer">
	<p class="left">&copy; Jiangshui 一个努力坚持中低质量原创的<a class="color-egg" href="/images/meinanzi.png">美男子</a>。生活不易，<a href="#">包养本人</a>。</p>
	<p class="right">Base on <a href="https://github.com/yujiangshui/jiangshui-simple">Github</a> and <a href="http://hexo.io/">Hexo</a> .</p>
</div>
	</div>
</div>

</body>
</html>